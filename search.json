                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    [{"title":"Linux权限管理命令","date":"2019-09-06T13:46:24.000Z","url":"/2019/09/06/Linux权限管理命令/","tags":["Linux","权限管理命令"],"categories":["Linux"],"content":"Linux权限管理命令chmod改变文件或目录权限命令名称：chmod命令原意：change the permissions mode of a life所在路径：/bin/chmod执行权限：所有用户语法：chmod[{ugoa}{+-=}{rwx}][文件或目录]chmod[mode=421][文件或目录]-R 递归修改功能描述：改变文件或目录权限注意ugoa分别是user、group、other、all几个用户同时设置权限可以使用逗号风格，例如g+w，o-r权限数字表示r-4 w-2 x-1，则rwx为7，rw-为6，以此类推3可以这样用chmod 762 hello-R可以让某个目录被改变的同时目录下所有文件权限都被改变目录的权限和文件的权限不太相同，目录的权限如果大于文件，以目录为准chown改变文件或目录的所有者命令名称：chown命令原意：change file ownership所在路径：/bin/chown执行权限：管理员语法：chown[用户][文件或目录]功能描述：改变文件或目录的所有者chgrp改变文件或目录的所属组命令名称：chgrp命令原意：change file group ownership所在路径：/bin/chgrp执行权限：所有用户语法：chgrp[用户组][文件或目录]功能描述：改变文件或目录的所属组注意用户创建文件后的默认组是创建者的缺省组（默认组）缺省创建的文件不具有可执行性（针对文件）umask显示、设置文件的缺省权限命令名称：umask命令原意：the user file-creation mask所在路径：Shell内置命令执行权限：所有用户语法：umask[-S]-S 以rwx形式显示新建文件缺省权限功能描述：显示、设置文件的缺省权限注意直接输umsk得到的是掩码777-掩码得到的是实际值更改只需要umask [掩码值]++不建议更改++"},{"title":"Linux文件处理命令","date":"2019-09-05T11:04:02.000Z","url":"/2019/09/05/Linux文件处理命令/","tags":["Linux","文件处理命令"],"categories":["Linux"],"content":"命令概况命令格式：命令 [-选项] [参数]例如：ls -la /etc部分命令不遵循这样的格式简化选项：-a 完整选项 –all等价任何命令终止 ctrl+c以下内容摘自兄弟连新版Linux命令格式与目录处理命令ls命令命令名称：ls命令原意：list所在路径：/bin/ls执行权限：所有用户功能描述：显示目录文件语法：ls 选项[-ald][文件或目录]    -a 显示所有文件，包括隐藏文件（点开头为隐藏文件 .abc）    -l 详细信息显示    -d 查看目录属性    -i 文件唯一标识 i节点使用技巧ls直接输入：当前目录-lh（-h）可以人性化显示文件大小可以不加参数文件引用计数-ld看目录本身属性三类用户：user（所有者/可改）group（用户组（可以使用的用户组））other（不包括以上）u   g   o-rw-r–r–-开头为文件dr开头为目录l开头软链接r读 w写 x执行mkdir创建目录命令名称：mkdir命令原意：make directories所在路径：/bin/mkdir执行权限：所有用户语法：mkdir -p [目录名]功能描述：创建新目录                  -p 递归创建例子：mkdir /tmp/hello使用技巧一口气创建多个重叠的目录的话：mkdir -p /tmp/hello/helloagaincd切换目录命令名称：cd命令原意：change directory所在路径：shell内置命令执行权限：所在用户语法：cd[目录]功能描述：切换目录例子：cd /hello使用技巧cd . 当前目录cd .. 上一级目录rmdir删除空目录命令名称：rmdir命令原意：remove empty directories所在路径：/bin/rmdir执行权限：所有用户语法：rmdir[目录名]功能描述：删除空目录使用技巧只能删除空目录，若目录下有文件则无法删除pwd显示全路径可用pwd命令直接出全路径cp复制文件或目录命令名称：cp命令原意：copy所在路径：/bin/cp执行权限：所有用户语法：cp -rp [原文件或目录][目标目录]                 -r 复制目录                 -p 保留文件属性功能：复制文件或目录使用技巧同时复制多文件写法：cp /bin/hello.log /bin/bye.log /tmp操作完成后两个日志文件就复制到/tmp中去了若保留文件属性，则修改时间不会因为复制文件而改变也可在复制中改名：cp -r /tmp/hello /tmp/wellmv剪切文件，改名命令名称：mv命令原意：move所在路径：/bin/mv执行权限：所有用户语法：mv [原文件或目录][目标目录]功能描述：剪切文件、改名使用技巧在当前目录下的话可直接打文件名或./部分路径也可像复制一样动用多个文件和改名rm删除文件命令名称：rm命令原意：remove所在路径：/bin/rm执行权限：所有用户语法：rm -rf[文件或目录]                 -r 删除目录                 -f 强制执行（无询问）功能描述：删除文件touch创建空文件命令名称：touch所在路径：/bin/touch执行权限：所有用户语法：touch [文件名]功能描述：创建空文件使用技巧可以同时创建多个文件建立带空格的文件名，要使用：touch “program files”不建议，对于后续操作很麻烦cat显示文件内容命令名称：cat所在路径：/bin/cat执行权限：所有用户语法：cat [文件名]功能描述：显示文件内容                    -n 显示行号使用技巧注意，cat浏览长文件只看最后一页的内容tac显示文件内容（反向显示）命令名称：tac所在路径：/bin/tac执行权限：所有用户语法：tac [文件名]功能描述：显示文件内容（反向显示）more分页显示文件内容命令名称：more所在路径：/bin/more执行权限：所有用户语法：more [文件名]            （空格）或f 翻页            （Enter）   换行                q或Q            退出功能描述：分页显示文件内容使用技巧想翻页用less命令less分页显示文件内容（可向上翻页）命令名称：less所在路径：/bin/more执行权限：所有用户语法：less [文件名]            （空格）或f 翻页            （Enter）   换行             ⬆上一行 page up上一页功能描述：分页显示文件内容（可向上翻页）使用技巧搜索关键词 使用/(关键词)head显示文件前面几行命令名称：head所在路径：/bin/head执行权限：所有用户语法：head [文件名]功能描述：显示文件前面几行                    -n 指定行数范例：head -n 20 /tmp/hellotail显示文件后面几行命令名称：tail所在路径：/bin/tail执行权限：所有用户语法：tail [文件名]功能描述：显示文件前面几行                    -n 指定行数                    -f 动态显示文件末尾内容使用技巧-f命令下可以实时更新内容ln生成链接文件命令名称：ln命令原意：link所在路径：/bin/ln执行权限：所有用户语法：ln -s [原文件][目标文件]                 -s 创建软连接功能描述：生成链接文件使用技巧软链接：lrwxrwxrwx 类似windows快捷方式                此权限不代表源文件权限，所有软连接都是这个开头硬链接：1、拷贝cp -p + 同步更新2、通过i节点识别 （原文件和硬链接节点相同）3、不能跨分区（软链接可以）4、不能针对目录使用（软链接可以）"},{"title":"C语言操作题","date":"2019-09-01T14:08:55.000Z","url":"/2019/09/01/C语言操作题/","tags":["C","国家二级计算机考试"],"categories":["C"],"content":"1.2.1编程时注意定义的变量类型例如void fun(int a, int b, long *c){    int a1,a2,b1,b2;    a1=a%10;    a2=(a/10)%10;    b1=b%10;    b2=(b/10)%10;}其中勿将*c赋值变成了c赋值成地址了。2.3.1编程时的自定义函数如果要求返回要用return变换类型写法必须严格，例如（int）x四舍五入灵活写法：double fun(double x){  x=(int)(x100+0.5);  /*移动小数点/  x/=100;  /舍掉小数点后两位/  return x;  }加0.5完事"},{"title":"C语言基础知识习题","date":"2019-09-01T14:08:38.000Z","url":"/2019/09/01/C语言基础知识习题/","tags":["C","国家二级计算机考试"],"categories":["C"],"content":"整型变量占用4个字节的内存空间，而双精度型变量占用8个字节的内存空间。C语言规定必须以main作为主函数名。程序中的main( )是主函数的起始行，也是C程序执行的起始行。每一个可执行的C程序都必须有一个且只能有一个主函数。一个C程序中可以包含任意多个不同的函数，但只能有一个主函数。程序要从main()函数开始执行，最后在main()函数中结束。所以大写的MAIN是不允许的。计算机程序都是编译为二进制的代码，计算机才会执行。计算算式也是。C语言规定，不能在函数的内部定义函数。在C语言中注释内容必须放在“/”和“/”之间，“/”和“/”必须成对出现，按语法规定在注释之间不可以再嵌套“/”和“/”。C语言中的注释可以出现在程序中的任何位置，但是不能夹在变量或者关键字之间；C语言的变量在函数开始位置进行定义，也可以在变量使用前位置定义；一个浮点数可以和一个整数相加，运算符两侧的运算类型也可以不一致；数值常量中不允许夹带空格。合法的标识符要满足组成字符为az以及AZ，数字字符0到9和下划线，其中数字不开头，不能是关键字。选项B）中，&amp;不属于组成字符，是错误的。指数法表示时，指数部分须为整型，115L后加入L是说明此变量为长整型，是正确的常量表示形式。保留字不能用作用户的标识符。C语言中的用户标识符只能由字母，数字和下划母组成。C语言的标识符可分为以下3类：①关键字。C语言预先规定了一批标识符，它们在程序中都代表着固定的含义，不能另作他用。这些字符称为关键字。例如，int、double、if、else、while、for等。②预定义标识符。即预先定义并具有特定含义的标识符。③用户标识符。由用户根据需要定义的标识符称为用户标识符，又称自定义标识符，一般用来给变量、函数、数组等命名。C语言规定了一个标识符允许的字符个数，为32，超过的字符将不被识别。逗号表达式。逗号表达式的求解过程是：先求解表达式1，再求解表达式2，整个逗号表达式的值是表达式2的值."},{"title":"C语言结构体、共用体、位运算以及文件操作习题","date":"2019-09-01T12:42:56.000Z","url":"/2019/09/01/C语言结构体、共用体、位运算以及文件操作习题/","tags":["C","国家二级计算机考试"],"categories":["C"],"content":"（1）以下叙述中错误的是A）可以用typedef将已存在的类型用一个新的名字来代表B）可以通过typedef增加新的类型C）用typedef定义新的类型名后，原有类型名仍有效D）用typedef可以为各种类型起别名，但不能为变量起别名C语言允许用typedef说明一种新类型名，说明新类型名的语句一般形式为：typedef  类型名  标识符；在此，“类型名”必须是在此语句之前已有定义的类型标识符。“标误符”是一个用户定义标识符，用作新的类型名。typedef语句的作用仅仅是用“标识符”来代表已存在的“类型名”，并未产生新的数据类型，原有类型名依然有效。示例:typedef unsigned char BYTE;typedef struct Books{   char  title[50];   char  author[50];   char  subject[100];   int   book_id;} Book;结构体：struct tag {    member-list    member-list    member-list    …} variable-list ;int a[10] 和 int (a)[10] 的区别：int a[10]定义了整型指针数组a，每个空间里都有int。int (*a)[10]定义了一个指向一维数组的指针a，直接指向数组，没有所谓10个存放空间。struct SIMPLE{    int a;    char b;    double c;};//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3struct SIMPLE t1, t2[20], *t3;//也可以用typedef创建新类型typedef struct{    int a;    char b;    double c;} Simple2;//现在可以用Simple2作为类型声明新的结构体变量Simple2 u1, u2[20], *u3;（11）有以下程序 #include &lt;stdio.h&gt;typedef struct { int b, p; } A;void f(A c) /* 注意：c是结构变量名 */ { int j;c.b += 1; c.p+=2; }main() { i; A a={1,2};f(a);printf(“%d,%d\\n”, a.b, a.p); }程序运行后的输出结果是A）2,4B）1,2C）1,4D）2,3在C语言中，数据只能从实参单向传递给形参，称为“按值”传递。也就是说，当简单变量作为实参时，用户不可能在函数中改变对应实参的值。所以本题中在main()函数f(a)语句中结构体实参a作为值，传递给函数f(A c)中的形参c;这种值传递的方式不会对实参a产生任何影响，所以结构体实参a的值不会发生变化。（13）设有定义：struct complex { int real,unreal;}data1={1,8},data2;则以下赋值语句中错误的是A）data2=(2,6);B）data2=data1;C）data2.real=data1.real;D）data2.real=data1.unreal;本题主要考查结构体变量的定义与初始化。题目中定义了complex类型的结构体变量data1和data2,并对data1进行了初始化。可以用一个结构体变量对另一个结构体变量赋值，用一个结构体变量的成员对另一个结构体变量的成员赋值。（16）程序中已构成如下图所示的不带头结点的单向链表结构，指针变量s、p、q均已正确定义，并用于指向链表结点，指针变量s总是作为头指针指向链表的第一个结点。若有以下程序段： q=s;  s=s-&gt;next;  p=s; while(p-&gt;next) p=p-&gt;next; p-&gt;next=q; q-&gt;next=NULL;该程序段实现的功能是A）尾结点成为首结点B）首结点成为尾结点C）删除首结点D）删除尾结点分析程序可知，程序段首先让q指向链表的首结点，s指向链表的第二结点，p此时指向链表的第二个结点。然后在while循环中，当p的后继结点非空时，让p指向链表的最后一个结点，退出循环。然后让尾结点指向首结点，并使首结点的后继结点为NULL。所以最终实现链表的首结点成为尾结点。（17）有以下结构体说明、变量定义和赋值语句 struct STD { char name[10]; int age; char sex; } s[5],*ps; ps=&amp;s[0]; 则以下scanf函数调用语句有错误的是A）scanf(“%d”,&amp;s[0].age);B）scanf(“%c”,&amp;(ps-&gt;sex));C）scanf(“%s”,s[0].name);D）scanf(“%d”,ps-&gt;age);程序段定义了结构体变量数组s[5]和指针变量ps，然后ps指向数组s[5]中的第一个元素，因而ps-&gt;age引用s[0].age。因为在输入scanf()函数中，第2个参数应该表示为地址变量，而选项A）表示的值，而不是一个地址值。如果p指向结构体，那么下面三种形式都可以访问结构体的成员：结构体变量．成员名、(*p)．成员名、p-&gt;成员名。一、结构体struct??? 各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。二、联合体union??? 各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。不允许对联合体变量名U2直接赋值或其他操作。此处出自：版权声明：本文为博主原创文章，遵循 CC 4.0 by-sa 版权协议，转载请附上原文出处链接和本声明。本文链接：共用体是构造数据类型,也叫联合体它使几个不同类型的变量共占一段内存(相互覆盖),每次只有一个能使用.结构体则不然, 每个成员都会有存储空间的,可以一起用.位运算：转换成二进制后再操作，位移动相当于每位移动。位运算符~    &amp;    |    ^按位取反    位与    位或    异或移位运算符&lt;&lt;    &gt;&gt;左移    右移（48）有以下程序main() {unsigned char a=2, b=4, c=5, d;d = a | b; d &amp;= c;printf(“%d\\n”, d); }程序运行后的输出结果是A）3B）5C）4D）6本题考查位运算，|为按位或运算，&amp;为按位与运算，按位与（&amp;）运算符的作用是：把参加运算的两个运算数按对应的二进制位分别进行“与”运算，当两个相应的位都为1时，该位的结果为1；否则为0。按位或（|）的运算规则是：参加运算的两个运算数中，只要两个相应的二进制位中一个为1，则该位的运算结果即为1；只有当两个相应位的数都为0时，该位的运算结果才为0。首先d=2|4值为6，d=6&amp;5值为4。（49）下面选项中关于位运算的叙述正确的是A）位运算符都需要两个操作数B）左移运算的结果总是原操作数据2倍C）右移运算时，高位总是补0D）位运算的对象只能是整型或字符型数据位运算则是以位（bit）一级进行的运算，位运算符中除“~”以外，均为二元运算符，即要求两侧各有一个运算量，运算量只能是整型或字符型的数据，不能为实型数据。其中右移时，右端（低位）移出的二进制数舍弃，左端（高位）移入的二进制数分两种情况：对于无符号整数和正整数，高位补0；对于负整数，高位补1。而左移运算在没有溢出的前提下每移动一位，相当于原数据的2倍。（62）下列关于C语言文件的叙述中正确的是A）文件由结构序列组成，可以构成二进制文件或文本文件B）文件由一系列数据依次排列组成，只能构成二进制文件C）文件由数据序列组成，可以构成二进制文件或文本文件D）文件由字符序列组成，其类型只能是文本文件在C语言中，对输入、输出的数据都按“数据流”的形式进行处理。数据可以按文本形式或二进制形式存放在介质上，因此文件可以按数据的存放形式分为文本文件和二进制文件。需要注意的是：用“w”打开的文件只能向该文件写入。若打开的文件不存在，则以指定的文件名建立该文件，若打开的文件已经存在，则将该文件删去，重建一个新文件。buffer是数据块的指针，对fread来说，它是内存块的首地址，输入的数据存入此内存块中；EOF是在stdio.h库函数文件中定义的符号常量，其值等于-1。EOF用作文件结束标志，在二进制或者文本文件内部有一个位置指针，用以指示文件内部的当前读写位置。使用fgetc函数，每读写一次，该指针均向后移动， feof用来判断文件是否结束。如果遇到文件结束，函数feof（fp）的值为1，否则为0。"},{"title":"C语言编译预处理和指针习题","date":"2019-09-01T12:42:10.000Z","url":"/2019/09/01/C语言编译预处理和指针习题/","tags":["C","国家二级计算机考试"],"categories":["C"],"content":"在C语言中，凡是以“#”号开头的行，都称为“编译预处理”命令行。预处理命令可以放在程序中的任何位置，其有效范围是从定义开始到文件结束。预处理命令有宏定义、文件包含和条件编译三类。#define S(x) PTxx ;预处理语句后面不能加分号，因此程序有错。而且注意，带入后是没有小括号加持的。（10）若程序中有宏定义行： #define N 100 则以下叙述中正确的是A）宏定义行中定义了标识符N的值为整数100B）上述宏定义行实现将100赋给标示符NC）在运行时用100替换标识符ND）在编译程序对C源程序进行预处理时用100替换标识符ND。并非在运行时替换，而是在编译时。 int p; p=(int)malloc(sizeof(int));内存中每次动态的申请一个整型变量的存储空间有时题目会让多个指针变量指向同一个内存区域。void fun(int *p1,int *p2,int *s ) {s=( int * )malloc( sizeof(int) );*s = *p1 + *(p2++); } main() {int a[2]={1,2 }, b[2]={10,20}, *s=a;fun( a,b,s );printf(“%d\\n”, *s ); } 主函数中定义指针s指向数组a，调用fun函数，首先是实参传给形参，因此p1指向a，p2指向b，s指向a，即s的值为1。流程到调用函数fun执行，首先更改s的指向为新分空间的首地址，表达式s = *p1 + *(p2++)，取p1指向数据位1，加上p2指向数据10，p2后移，存放到s指向的空间中11.流程结束，形参s和p1，p2撤销，存入s指向空间的数据丢失，主函数输出s指向数据仍然是1。注意，如果不重新指向的话，会直接修改原来的指向内存，使结果为11。常量不得使用++void fun(int n,char s) { …… }void (*pf)(int, char); pf=fun;在给函数指针变量赋值时，只需给出函数名而不必给出参数以上使函数指针定义和赋值的正确方式。例如p=NULL;赋值语句，称p为空指针。这条语句等价于p=’\\0’;或p=0; 而不是p=\\0。（27）设有定义： int x=0, p; 紧接着的赋值语句正确的是A）p=NULL;B）p=NULL;C）p=x;D）*p=x;定义指针变量时，必须将指针变量初始化为NULL（为空），否则，如果不赋给它地址，系统会随机给它分配一个地址。int x=0, *p;p=x;指针变量的值只能是存储单元地址，而不能是一个整数，在头文件stdio.h中，NULL被定义为void型的指针。float *p=&x;指针变量直接赋值如上字符串赋值特殊情况：char* sp, s[10]; sp = “Hello”;属于指针操作。（34）若有定义语句： int a[2][3],p[3]; 则以下语句中正确的是A）p[0]=&amp;a[1][2];B）p[0]=a;C）p=a;D）p[1]=&a;定义语句int a[2][3],p[3];定义了整型二维数组a[2][3]和指针数组p[3]。在C语言中，二维数组名也是一个存放地址常量的指针，其值为二维数组中第一行的地址。所以选项A）中，把整型数组a[0]的指针赋给p[0]。37 main() {char *s ={ “abc” };do {printf (“%d”, *s%10);++s; } while ( *s ); } *s=/0?设有定义： char c; 以下选项中能够使c正确指向一个字符串的是A）char str[ ]=”string”; c=str;B）scanf(“%s”,c);C）c=getchar( );D）c=”string”;在题目的题干中定义了字符指针变量c，在选项A）中，首先定义字符数组str，然后再把字符数组str的首地址赋给字符指针变量c。所以选项A）是正确的。在选项D）中，如果在定义字符指针c时，同时给c赋初值时，这样的表达式是正确的。而本题不是在定义指针c时，同时给c赋初值。在指针定义语句double a,p=&amp;a中，指针变量p前面的号，只是一个说明符，说明变量p是指针类型的变量。在其它地方非定义语句中应当是间值运算符。（44）有以下程序void fun ( char *s ) { char a[10];strcpy( a, “STRING” ); s = a; } main() { char *p=”PROGRAM”; fun( p );printf(“%s\\n”,p); }程序运行后的输出结果是（此处□代表空格)A）STRING□□□□B）PROGRAMC）STRING□□□D）STRING函数fun的主要功能是把字符串”STRING”，存放到字符数组a中，s指向该字符串(不是修改实际值，只是改指向)，函数调用结束以后，释放s和a指向的空间。主函数调用fun（p），并不能更改p的值，因此p的指向没有改变。注意！其中的”PROGRAM”是常量，也就是为什么p的值无论如何也无法修改的原因！！！详情："},{"title":"C语言函数与数组习题","date":"2019-09-01T12:41:48.000Z","url":"/2019/09/01/C语言函数与数组习题/","tags":["C","国家二级计算机考试"],"categories":["C"],"content":"strcpy(s1, s2);复制字符串 s2 到字符串 s1。到null结束。strcat(s1, s2);连接字符串 s2 到字符串 s1 的末尾。strcmp比较字符串函数 返回1或0。A）main() { …… x=fun(2,10); ……} float fun(int a,int b){……}B）float fun(int a,int b){……} main() { …… x=fun(i,j); ……}C）float fun(int ,int); main() { …… x=fun(2,10); …… } float fun(int a,int b){……}D）main() { float fun(int i,int j); …… x=fun(i,j); …… } float fun(int a,int b){……}C语言规定,函数必须先定义，后调用（函数的返回值类型为int或char时除外）。在选项A）中，调用的子函数在调用后面定义，所以不正确。在选项B）、C）中，被调用函数在主函数之前定义，再在主函数中调用，所以是正确的；在选项D）中，在主函数中先对子函数float fun(int i,int j)进行了声明，然后进行调用。各个函数之间没有主从关系，不能嵌套定义函数。字符串长度函数strlen(s)表示计算出以s为起始地址的字符串的长度，并作为函数值返回。这个长度值不包括串尾的结束标志’\\0’。在C语言中要对两个字符串的大小进行比较，就需要调用字符串比较函数strcmp()，不能用==。（14）已定义以下函数 int fun( int *p) { return *p; } fun函数返回值是A）不确定的值B）一个整数C）形参p中存放的值D）形参p的地址值由函数int fun(int *p){return *p; }的定义可知，返回值为整型指针变量p所指向的数据。不是形参！在C语言中，数据只能从实参单向传递给形参，称为“按值”传递。也即是说，当简单变量作为实参时，用户不可能在函数中改变对应实参的值。（若是指针呢？指针会直接传递，因为是修改内存）有以下程序int add (int a,int b){return (a+b);}main( ){ int k,(f)( ),a=5,b=10;f=add;…} 则以下函数调用语句错误的是A）k=add(a,b);B）k=(f)(a,b);C）k= *f(a,b);D）k=f(a,b);在语句“k=f(a,b)”中，由于“（）”的优先级高于“”，所以“*f(a,b);”表示其返回类型为指针的带有两个整型参数的函数，而不是整型数值，因此选项C）为错误的调用形式。int fun(double *x, int n);一维数组的名字表示的是一维数组的地址。在C语言中，函数的实参单元与形参单元在内存中分配不同的存储单元。在调用函数时，给形参分配临时存储单元，并将实参对应的值传递给形参，在被调用函数中对形参存储单元中的值进行运算，最后通过return语句把函数值返回调用函数。当调用结束后，形参单元被释放，实参单元仍保留并维持原值。（35）有以下程序（strcat函数用以连接两个字符串)#include &lt;stdio.h&gt;#include &lt;string.h &gt;main(){ char a[20]=”ABCD\\0EFG\\0”, b[]=”IJK”; strcat (a,b); printf(“%s\\n”,a);}程序运行后的输出结果是A）ABCDE\\0FG\\0IJKB）ABCDIJKC）IJKD）EFGIJK在字符串中字符’\\0’表示字符串的结束标志，所以字符串a和b相连接的结果为ABCDIJK。不是只有在函数内部定义的变量才是局部变量，其它类、结构也算。局部变量可以说明为auto、register以及static。在C语言中，动态变量（auto）存储在内存中的动态存储区，在程序运行中，只有当调用变量所在的函数时，系统才临时给变量分配内存单元；全局变量（extern）一经定义，系统为其分配固定的内存单元；静态变量（static），编译系统为其分配固定的存储空间；寄存器变量（register）不保存在内存上，而是直接存储在CPU的寄存器中。C语言定义数组必须写清楚数组长度。在定义一维数组时，数组的下标应该是一个确定的整数值。要注意的是在定义二维数组时，其第一维下标可以省略，但第二维下标不能省略。且长度不得使用变量名代替。如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。C语言中字符串不能直接赋值，需要通过strcpy函数，或者for语句循环输入。char a[3]; a = “AB”;是非法的int num[][3]={ {1,2},3,4,5,6 };是合法的是换行符（83）若有定义： int w[3][5]; 则以下不能正确表示该数组元素的表达式是A）(w+3)B）((w+1))C）(w+1)[4]D）(&amp;w[0][0]+1)在C语言中，二维数组的名字表示的是二维数组的地址，对于二维数组 int w[3][5]，可以认为w为一个一维数组，含有3个元素，而每个元素为一个含有5个元素的一维数组。而(w+1)为一个含有两个元素的一维数组，首先和(w+1)[4]结合非法，4超出了二维数组的边界，取值也就是非法的了。可以用于存储字符串，但是字符串的存储不能通过赋值，仅可以初始化或者输入得到，对于指针变量可以保存常量字符串的地址。不可以对字符串进行关系运算，除非用字符串相关的函数。char s[5] = { ‘A’, ‘B’, ‘C’, ‘D’, ‘E’ };字符串中无法存放字符串结束标志‘\\0’；字符数组的每个元素可存放一个字符，并且最后一个元素必须是’\\0’字符，错误，例子：ab/0abscanf() 语句中用“空格”间隔不同的字符串，空格将被全部忽略掉，所以用scanf()函数不能输入空格； getchar()函数用于输入字符，其调用形式为：ch=getchar( ),getchar( )函数从终端读入一个字符作为函数值，把读入的一个字符赋给变量ch。在输入时，空格、回车符都将用于字符读入，而且只有在用户敲入Enter键时，读入才开始执行。gets()函数的调用形式为：gets(str_adr)，其中str_adr是存放输入字符串的起始地址，可以是字符数组名、字符数组元素的地址或字符指针变量。gets()函数用来从终端键盘读入字符串（包括空格符），直到读入一个换行符为止。getc()函数的调用形式为：ch=getc(pf)其中pf是文件指针。函数的功能是从pf指定的文件中读入一个字符，并把它作为函数值返回。字符数组s[ ]中的数组名s表示的是一个地址常量。所以语句“s+=2；”不能将指针在当前位置的基础上再向后移动两位。因而程序编译时出错。"},{"title":"C语言程序设计习题","date":"2019-09-01T12:41:18.000Z","url":"/2019/09/01/C语言程序设计习题/","tags":["C","国家二级计算机考试"],"categories":["C"],"content":"C语言本身没有提供输入输出语句，但是可以通过调用标准库函数中提供的输入和输出函数来实现输入和输出；采用printf输出数据，输出数据都默认为右对齐，若要左对齐，可以在格式控制中的“%”和宽度之间加一个“-”号来实现；printf的输出精度由变量的类型决定，与域宽无关。%8.6f代表浮点数输出输出，共占8列，其中有6位小数，如数值宽度（总宽度）小于8左端补空格。输出“%”，可以在格式控制中用“%%”表示，将输出一个“%”，而没有%表示格式符的开始，%%d不能表示格式符，因此仅输出：a=%d,b=%d。在使用scanf函数进行输入数据时，输入的数据之间必须用空格、回车符、制表符（Tab键）等间隔符隔开，但是空格为合法的字符型数据的输入。而按照格式符”%d%c%d%c”说明，数值型数据和字符数据输入之间不要加入空格间隔，而字符型数据和数值型数据的输入却可以加入任意的空格，回车和跳格。在输入函数scanf的输入格式符%2d%f中，2d表示输入的数据的宽度为2，所以当从键盘输入876543.0时，这时把输入数字串的前两位87赋给变量a，然后将紧接着将6按照格式控制符%f的形式赋给变量b，所以b的值为6.000000。%d；%d在采用scanf这个函数输入数据时，要严格遵守其输入的规则定义。本题此函数定义的规则是，在两个整数之间加分号输入（3；5）%f和%lf分别是float类型和double类型用于格式化输入输出时对应的格式符号。其中：float，单精度浮点型，对应%f.double,双精度浮点型，对应%lf.在用于输出时:float类型可以使用%lf格式，但不会有任何好处。double类型如果使用了%f格式可能会导致输出错误。在用于输入时:double 类型使用了%f格式，会导致输入值错误。float类型使用double类型不仅会导致输入错误，还可能引起程序崩溃。所以在输入输出时，一定要区分好double和float，而使用对应的格式符号。逻辑运算的短路特性：(表达式1）&amp;&amp;(表达式2) 如果表达式1为假，则表达式2不会进行运算，即表达式2“被短路”(表达式1）||(表达式2) 如果表达式1为真，则表达式2不会进行运算，即表达式2“被短路”36若有定义： float x=1.5; int a=1,b=3,c=2; 则正确的switch语句是A）switch(a+b) { case 1: printf(“\\n”); 　case 2+1: printf(“*\\n”); }B）switch((int)x); { case 1: printf(“\\n”); case 2: printf(“*\\n”); }C）switch(x) { case 1.0: printf(“\\n”); case 2.0: printf(“*\\n”); }D）switch(a+b) { case 1: printf(“\\n”); case c: printf(“*\\n”); }在C语言中，switch()后一对圆括号中的可以是整型表达式或字符表达式。case语句后面的常量表达式的类型必须与switch后圆括号中的表达式类型相同，各case语句标号的值应该互不相同，选项B）中switch后括号表达式出错，选项C）中case后面的常量类型不正确，选项D）中case后面出现了变量表达式，所以D）不正确。break为C语言关键字，又称间断语句。break语句的功能是跳出正在执行的条件语句或循环语句。它可以出现在switch语句中，也可以出现在循环语句中。default是关键字，起标号的作用，代表所有case标号之外的那些标号。default标号可以出现在语句体中任何标号位置上。在switch语句体中也可以没有default标号。（53）在以下给出的表达式中，与while(E)中的(E)不等价的表达式是A）(E&gt;0||E&lt;0)B）(! E==0)C）(E!=0)D）(E==0)在while(E)中，表达式E可以是C语言中任意合法的条件表达式，但不能为空，由它来控制循环体是否执行。在选项A）中表达式E&gt;0||E&lt;0 是一个逻辑表达式。for语句中的表达式可以部分或全部省略，但两个“;”不可省略。"},{"title":"关于python和c中for，while语句的小特点","date":"2019-08-01T15:02:44.000Z","url":"/2019/08/01/关于python和c中for，while语句的小特点/","tags":["C","python"],"categories":["python"],"content":"因为要用到python，稍微看了下，发现有些有趣的小特性。特性简单的来说，就是c的for语句中，最后自变量会多1.而python有点“神奇”以上区别显而易见了。附录："},{"title":"Labview数据图形显示","date":"2019-07-30T15:51:27.000Z","url":"/2019/07/30/Labview数据图形显示/","tags":["Labview","数据图形"],"categories":["Labview"],"content":"有个比较重要的一点就是关于动态数据尤其是一些图表显示要加入输入端，可以合成信号，而且信号坐标会相互对应。几乎所有的用于采集、分析、操作以及生成信号的Express VI都使用了一个特殊的数据类型传送信号数据，这个数据类型就是动态数据。简单地说，动态数据就是一个或多个通道的波形数据。实际上，你也可以将动态数据想象为只是一个简单的模拟波形的数组，用一个智能的线所表示。不过，在实际的使用中，动态数据确实也是非常智能的，比如将几个动态数据合并为一个动态数据的操作是非常简单的。在LabVIEW中，将一个动态数据连线到另一个动态数据，LabVIEW会自动的添加一个合并信号的函数将这两个信号线合并为一个信号线。资料来源："},{"title":"伯努利模型和多项式模型","date":"2019-07-29T13:54:09.000Z","url":"/2019/07/29/伯努利模型和多项式模型/","tags":["伯努利模型","多项式模型","朴素贝叶斯"],"categories":["机器学习"],"content":"伯努利模型它是一种基于独立重复试验，满足二项分布的概率模型，它的基本特征：① 在一组固定不变的条件下重复地做一种试验。② 每次试验的结果只有两个：事件发生或不发生。③ 每次试验中，相同事件发生的概率均一样。④ 各次重复试验的结果是相互独立的。在朴素贝叶斯中就是针对某个文本的每个特征只记录是否“出现”。多项式模型多项式模型是一种数学模型，一般的时间序列中的局部趋势可由低价多项式很好地逼近，特别是在短期预测中，我们用不超过高阶的多项式模型就能给出较好的对局部变化趋势的拟合。同时，当这种趋势模型与季节、回归等分量模型叠加时可以处理大部分的时间序列中的问题。多项式模型有低阶和高阶的类型。在朴素贝叶斯中就表现成一条多项式。推荐资料中：该模型常用于文本分类，特征是单词，值是单词的出现次数。P(xi|yk)=Nykxi+αNyk+αn其中，Nykxi是类别yk下特征xi出现的总次数；Nyk是类别yk下所有特征出现的总次数。对应到文本分类里，如果单词word在一篇分类为label1的文档中出现了5次，那么Nlabel1,word的值会增加5。如果是去除了重复单词的，那么Nlabel1,word的值会增加1。n是特征的数量，在文本分类中就是去重后的所有单词的数量。α的取值范围是[0,1]，比较常见的是取值为1。待预测样本中的特征xi在训练时可能没有出现，如果没有出现，则Nykxi值为0，如果直接拿来计算该样本属于某个分类的概率，结果都将是0。在分子中加入α，在分母中加入αn可以解决这个问题。推荐资料朴素贝叶斯的三种模型"},{"title":"Labview循环与结构小计","date":"2019-07-29T02:39:13.000Z","url":"/2019/07/29/Labview循环与结构小计/","tags":["Labview","循环"],"categories":["Labview"],"content":"For循环是从0执行到N-1。若要同时执行多个for语句，可右键配置循环并并行。（指单个循环结构克隆出多个同时进行）注意，并行运行的循环必须独立于所有其他循环。前提：选择“工具”→“性能分析”→“查找可并行循环”。移位寄存器相当于添加一个变量用于各个循环间信息传递。并行循环将自动把移位寄存器变成错误寄存器。错误寄存器和移位寄存器的运行时的行为不同（？）。层叠移位寄存器（在移位寄存器上右键添加元素），用于访问以前多次循环的值。第一个即前一次循环，第二个即前两次循环，以此类推。（误差值处理？）关于循环中的自动索引默认情况下，将任一数组连接到For循环时都会启用自动索引，因为For循环的常见应用是处理单个数组元素。默认情况下，在接入或接出While循环时禁用自动索引，因此接线隧道将是实心的。（要右键节点手动打开）如果将一个数组通过自动索引的方式连接至For循环输入端，LabVIEW会把计数终端设置数组的大小，因此您无需连接计数终端。如果两个不同长度的数组通过自动索引的方式连接至For循环中，则长度较短的数组的元素个数决定循环的次数。示例：两个数组元素个数分别为4和8的数组被自动索引到For循环中，则循环执行次数将为4次。如果两个不同长度的数组通过自动索引的方式连接至While循环中，那么它们都将被索引，直到循环结束（由条件接线端决定），而且当数组没有数据后，在后续的每次迭代中，数组元素的数据类型的默认值将自动填充为数组的其余部分。 While循环具有独立于数组的停止条件，因此编写程序时需要注意在适当时停止While循环，从而避免将错误数据添加到输入和输出数组。开索引的时候输出的是一个数组，不开索引的话，输出的是最后那个数字。例子：输入一个数，输出自动索引打开时会记录每次循环的结果。            输入一个数组时，自动索引打开的情况下，每次循环都是会用输入数组的下一个数据，输出也存放在下一个数据中。            注：当总循环次数小于输入数组长度的话，输出数组大小为总循环次数N-1。反馈节点：反馈节点使用连线至初始化接线端的值作为第一次程序框图执行或循环的初始值。如初始化接线端未连线任何值，该VI使用数据类型的默认值。反馈节点可保存上一次执行或循环的结果。条件结构框没有自动索引和禁止索引。顺序结构作用：避免同时执行。平铺式顺序结构和层叠式顺序结构用途一致，顾名思义。事件结构中右键可以添加事件。公式节点：为了避免出现混乱的排版而出现的文本编辑实现程序逻辑的节点。注：变量大小写敏感。语法和C语言类似。属性节点：右键控件→创建右属性节点即可，用来实时改变程序中出现的控件属性。定时循环和定时顺序结构用来协调多个对时间要求严格的测量任务。循环定时优先级数字越大优先级越大。相同优先级数字下，定时顺序的第一帧的优先级高于定时循环的优先级。"},{"title":"Labview的一些小技巧（持续更新）","date":"2019-07-29T02:05:20.000Z","url":"/2019/07/29/Labview的一些小技巧（持续更新）/","tags":["Labview","变量","时间"],"categories":["Labview"],"content":"Labview操作记录集2019/7/29用工具面板里的手型工具，可以修改数值常量的值。按住ctrl再移动鼠标可扩大或缩小编程区域。变量和显示之间变量属性的转换要注意，保持良好的编程习惯。“整理程序框图”是个好东西，自动整理，思路更加清晰。Labview编程属于数据流编程，即所有输入端口上的数据都成为有效数据时，它才能被执行。变量创造法：局部变量：右键→创建 即可 或 程序框图中在“函数”选板的“结构”子选板中选择局部变量。全局变量：程序框图中在“函数”选板的“结构”子选板中选择全局变量。                    或者在labview的“新建”菜单中选择“全局变量”。（一个“全局”VI）                    （可以放很多控件，这样选择项中有很多选择）使用计算时间的程序中基准时间有时不为0，所以要两个计时器相减，其中一个作为基准时间。同步开始定时结构用于程序框图中各定时结构的起始时间同步。定时结构用于停止VI。"},{"title":"树构造算法","date":"2019-07-28T11:34:15.000Z","url":"/2019/07/28/树构造算法/","tags":["ID3","CART"],"categories":["机器学习"],"content":"写在前头在决策树算法这边碰到了点新东西，姑且记录下，以后会补充。以下信息都来自互联网，本人也本着学习的态度拼接下，方便阅读。（信息时代牛皮）树构造算法ID3算法ID3算法是一种贪心算法，用来构造决策树。ID3算法起源于概念学习系统（CLS），以信息熵（博主注：信息的复杂度）的下降速度为选取测试属性的标准，即在每个节点选取还尚未被用来划分的具有最高信息增益的属性作为划分标准（博主注：即“最明显的特征”来划分），然后继续这个过程，直到生成的决策树能完美分类训练样例。信息增益（information gain）： 在划分数据集前后信息发生的变化称为信息增益。所要用到的数据必须是离散化数据，例如原数据为（yes，yes，no）可记为（1 1 0）。这里可以了解下独热编码独热编码即 One-Hot 编码，又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。CART算法CART算法考虑到每个节点都有成为叶子节点的可能，对每个节点都分配类别。分配类别的方法可以用当前节点中出现最多的类别，也可以参考当前节点的分类错误或者其他更复杂的方法。CART算法仍然使用后剪枝。在树的生成过程中，多展开一层就会有多一些的信息被发现，CART算法运行到不能再长出分支为止，从而得到一棵最大的决策树。然后对这棵大树进行剪枝。"},{"title":"Labview字符串函数","date":"2019-07-26T13:49:36.000Z","url":"/2019/07/26/Labview字符串函数/","tags":["Labview"],"categories":["Labview"],"content":"简单聊聊那么开始吧注意，本博客操作基于Labview 2018版注意，本博客只会列举一些博主不太会的东西概念定点数：定点数是指计算机中采用的一种数的表示方法。参与运算的数的小数点位置固定不变。操作各类控件 右键→属性 中有很多可以更改的选项，比如“显示格式”一类的。修改显示格式无法修改进制时，是因为不能用DBL，要用整型才行。程序连线工具如下：数学-数值-缩放 下的VI可以用来AD转换。注意点字符串操作会在一些数据交流（下位机与上位机交流）时会用到，灵活使用相应模块即可。"},{"title":"关于本站","date":"2019-07-25T02:20:34.000Z","url":"/2019/07/25/关于本站/","tags":["note"],"categories":["杂"],"content":"本站基于hexo+github生成主要记录一些关于学习过程中出现的小问题现在还不太会用hexo，慢慢来吧"}]